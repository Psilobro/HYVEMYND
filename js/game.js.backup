// --- CONFIG ---
window.CELL_RADIUS = 38;

window.GRID_RADIUS = 4;
const DIRS = [
    {dq:1,dr:0},{dq:1,dr:-1},{dq:0,dr:-1},
    {dq:-1,dr:0},{dq:-1,dr:1},{dq:0,dr:1}
];

function isNearBorder(q, r) {
    return Math.abs(q) > GRID_RADIUS || Math.abs(r) > GRID_RADIUS;
}

const COLORS = { white:0xFFFFFF, black:0x000000 };
const THEME  = {
    boardFill: 0xC27B15,
    boardLine: 0x4B382A,
    boardShadowColor: 0xB0515,
    boardHighlightColor: 0xFFB3D,
    highlight: 0x8B3E20
};

const SETUP = [
    {key:'Q',count:1},
    {key:'A',count:3},
    {key:'G',count:3},
    {key:'B',count:2},
    {key:'S',count:2}
];

// --- STATE ---
let state = {
    current:'white',
    moveNumber:1,
    queenPlaced:{white:false,black:false},
    gameOver: false
};
let selected = null;
let legalZones = new Set();
let animating = false;

// --- PIECE-SPECIFIC ANIMATIONS ---
function animatePieceMovement(piece, fromQ, fromR, toQ, toR, occBefore, onComplete) {
    const pieceType = piece.meta.key;
    
    // Get the target position
    const cell = cells.get(`${toQ},${toR}`);
    const targetPos = axialToPixel(toQ, toR);
    const targetY = targetPos.y - (cell.stack.length - 1) * 6;
    
    // Play sound effect based on piece type
    if (window.playSound) {
        const soundMap = {
            'Q': 'queen-move',
            'S': 'spider-move', 
            'A': 'ant-move',
            'B': 'beetle-move',
            'G': 'grasshopper-move'
        };
        window.playSound(soundMap[pieceType] || 'placement');
    }
    
    switch (pieceType) {
        case 'Q':
            animateQueenWaggle(piece, targetPos.x, targetY, onComplete);
            break;
        case 'S':
            animateSpiderStepByStep(piece, fromQ, fromR, toQ, toR, occBefore, onComplete);
            break;
        case 'A':
            animateAntDarting(piece, fromQ, fromR, toQ, toR, targetPos.x, targetY, onComplete);
            break;
        case 'B':
            animateBeetleClimbing(piece, targetPos.x, targetY, onComplete);
            break;
        case 'G':
            animateGrasshopperJump(piece, targetPos.x, targetY, onComplete);
            break;
        default:
            // Fallback to simple movement
            gsap.to(piece, {
                x: targetPos.x,
                y: targetY,
                duration: 0.5,
                onComplete: onComplete
            });
    }
}

function animateQueenWaggle(piece, targetX, targetY, onComplete) {
    const timeline = gsap.timeline({ onComplete: onComplete });
    const startX = piece.x;
    const startY = piece.y;
    const midX = (startX + targetX) / 2;
    
    timeline
        .to(piece, { 
            x: midX + 15, 
            y: startY - 10,
            duration: 0.15,
            ease: "power2.out"
        })
        .to(piece, { 
            x: midX - 10, 
            y: (startY + targetY) / 2,
            duration: 0.15,
            ease: "power2.inOut"
        })
        .to(piece, { 
            x: targetX + 12, 
            y: targetY - 8,
            duration: 0.15,
            ease: "power2.inOut"
        })
        .to(piece, { 
            x: targetX, 
            y: targetY,
            duration: 0.15,
            ease: "power2.in"
        });
}

function animateSpiderStepByStep(piece, fromQ, fromR, toQ, toR, occBefore, onComplete) {
    // Use the original board state for pathfinding, not the current modified state
    const allPaths = getSpiderPaths(fromQ, fromR, occBefore);
    
    // Find the path that ends at the target destination
    let targetPath = null;
    if (allPaths && allPaths.length > 0) {
        for (const path of allPaths) {
            const lastStep = path[path.length - 1];
            if (lastStep[0] === toQ && lastStep[1] === toR) {
                targetPath = path;
                break;
            }
        }
    }
    
    if (!targetPath) {
        // This should never happen now that we're using the original board state
        console.error(`ERROR: No valid spider path found for move from ${fromQ},${fromR} to ${toQ},${toR}`);
        console.error('This indicates a serious bug - spider move was allowed but no 3-step path exists!');
        console.error('Original board state:', occBefore);
        
        // Fall back to direct movement to prevent crashes
        gsap.to(piece, {
            x: axialToPixel(toQ, toR).x,
            y: axialToPixel(toQ, toR).y - (cells.get(`${toQ},${toR}`).stack.length - 1) * 6,
            duration: 0.5,
            onComplete: onComplete
        });
        return;
    }
    
    const timeline = gsap.timeline({ onComplete: onComplete });
    
    // Animate through each step with pauses
    for (let i = 1; i < targetPath.length; i++) {
        const [q, r] = targetPath[i];
        const pos = axialToPixel(q, r);
        const isLastStep = i === targetPath.length - 1;
        const cell = cells.get(`${q},${r}`);
        const yOffset = isLastStep ? -(cell.stack.length - 1) * 6 : 0;
        
        timeline
            .to(piece, {
                x: pos.x,
                y: pos.y + yOffset,
                duration: 0.3,
                ease: "power2.inOut"
            })
            .to({}, { duration: isLastStep ? 0 : 0.25 }); // Pause between steps, except on last
    }
}

function animateAntDarting(piece, fromQ, fromR, toQ, toR, targetX, targetY, onComplete) {
    // Now we have the exact target coordinates passed directly!
    
    // Define hex directions
    const directions = [
        {dq: 1, dr: 0}, {dq: 1, dr: -1}, {dq: 0, dr: -1},
        {dq: -1, dr: 0}, {dq: -1, dr: 1}, {dq: 0, dr: 1}
    ];
    
    // Get occupied positions
    const occupied = new Set();
    cells.forEach((cell, key) => {
        if (cell && cell.stack && cell.stack.length > 0) {
            occupied.add(key);
        }
    });
    
    // Remove ant's current position
    occupied.delete(`${fromQ},${fromR}`);
    
    // Find perimeter positions (empty spaces adjacent to occupied spaces)
    const perimeter = new Set();
    occupied.forEach(key => {
        const [oq, or] = key.split(',').map(Number);
        directions.forEach(dir => {
            const nq = oq + dir.dq;
            const nr = or + dir.dr;
            const nkey = `${nq},${nr}`;
            if (!occupied.has(nkey) && cells.has(nkey)) {
                perimeter.add(nkey);
            }
        });
    });
    
    // Add start and target to perimeter
    perimeter.add(`${fromQ},${fromR}`);
    perimeter.add(`${toQ},${toR}`);
    
    // Create a fast, twitchy path with more stops for longer distances
    const distance = Math.abs(toQ - fromQ) + Math.abs(toR - fromR);
    const baseStops = 4;
    const extraStops = Math.floor(distance / 2); // More stops for longer distances
    const numStops = baseStops + extraStops; // 4-10+ stops depending on distance
    
    const pathPoints = [];
    let currentQ = fromQ;
    let currentR = fromR;
    
    for (let i = 0; i < numStops; i++) {
        const isLastStop = i === numStops - 1;
        
        if (isLastStop) {
            // Final stop: go to exact target coordinates
            pathPoints.push({
                x: targetX,
                y: targetY,
                duration: 0.08 + distance * 0.01, // Longer final approach for distant moves
                pause: 0
            });
        } else {
            // Intermediate stop: find a twitchy perimeter position
            const possibleMoves = [];
            
            // Look for perimeter positions within reasonable distance
            for (const dir of directions) {
                const nextQ = currentQ + dir.dq;
                const nextR = currentR + dir.dr;
                const nextKey = `${nextQ},${nextR}`;
                
                if (perimeter.has(nextKey)) {
                    possibleMoves.push([nextQ, nextR]);
                }
            }
            
            // If no perimeter moves, try any empty adjacent space
            if (possibleMoves.length === 0) {
                for (const dir of directions) {
                    const nextQ = currentQ + dir.dq;
                    const nextR = currentR + dir.dr;
                    const nextKey = `${nextQ},${nextR}`;
                    
                    if (!occupied.has(nextKey) && cells.has(nextKey)) {
                        possibleMoves.push([nextQ, nextR]);
                    }
                }
            }
            
            // Pick a somewhat random move (prefer moves toward target, but add randomness)
            let chosenMove;
            if (possibleMoves.length > 0) {
                // 60% chance to pick move closest to target, 40% chance for random twitchy move (more randomness for longer paths)
                if (Math.random() < 0.6) {
                    let bestMove = possibleMoves[0];
                    let bestDistance = Math.abs(bestMove[0] - toQ) + Math.abs(bestMove[1] - toR);
                    
                    for (const move of possibleMoves) {
                        const moveDistance = Math.abs(move[0] - toQ) + Math.abs(move[1] - toR);
                        if (moveDistance < bestDistance) {
                            bestDistance = moveDistance;
                            bestMove = move;
                        }
                    }
                    chosenMove = bestMove;
                } else {
                    // Random twitchy move
                    chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
                
                currentQ = chosenMove[0];
                currentR = chosenMove[1];
            } else {
                // Fallback: move toward target
                const deltaQ = toQ - currentQ;
                const deltaR = toR - currentR;
                
                if (Math.abs(deltaQ) >= Math.abs(deltaR)) {
                    currentQ += Math.sign(deltaQ);
                } else {
                    currentR += Math.sign(deltaR);
                }
            }
            
            const pos = axialToPixel(currentQ, currentR);
            
            // Add some random jitter for twitchiness
            const jitterX = (Math.random() - 0.5) * 12;
            const jitterY = (Math.random() - 0.5) * 8;
            
            // Scale timing with distance - longer moves get more time per step
            const baseDuration = 0.04 + Math.random() * 0.03;
            const scaledDuration = baseDuration + (distance * 0.005); // Add time based on total distance
            const basePause = 0.01 + Math.random() * 0.02;
            const scaledPause = basePause + (distance * 0.003); // Add pause time based on distance
            
            pathPoints.push({
                x: pos.x + jitterX,
                y: pos.y + jitterY,
                duration: scaledDuration, // 0.04-0.12+ seconds depending on distance
                pause: scaledPause        // 0.01-0.05+ second pause depending on distance
            });
        }
    }
    
    // Build the timeline with twitchy movements
    const timeline = gsap.timeline({ onComplete: onComplete });
    
    for (const point of pathPoints) {
        timeline
            .to(piece, {
                x: point.x,
                y: point.y,
                duration: point.duration,
                ease: "power2.inOut"
            });
            
        if (point.pause > 0) {
            timeline.to({}, { duration: point.pause });
        }
    }
}

function animateBeetleClimbing(piece, targetX, targetY, onComplete) {
    const timeline = gsap.timeline({ onComplete: onComplete });
    const startX = piece.x;
    const startY = piece.y;
    
    // Climbing motion with vertical emphasis
    timeline
        .to(piece, { 
            x: startX + (targetX - startX) * 0.3, 
            y: startY - 25,
            duration: 0.2,
            ease: "power2.out"
        })
        .to(piece, { 
            x: startX + (targetX - startX) * 0.7, 
            y: startY - 30,
            duration: 0.15,
            ease: "power1.inOut"
        })
        .to(piece, { 
            x: targetX - 8, 
            y: targetY - 12,
            duration: 0.15,
            ease: "power1.inOut"
        })
        .to(piece, { 
            x: targetX, 
            y: targetY,
            duration: 0.1,
            ease: "power2.in"
        });
}

function animateGrasshopperJump(piece, targetX, targetY, onComplete) {
    // Keep the existing grasshopper animation (arc jump)
    const startX = piece.x;
    const startY = piece.y;
    const midX = (startX + targetX) / 2;
    const arcHeight = Math.abs(targetX - startX) * 0.5 + 30;
    
    const timeline = gsap.timeline({ onComplete: onComplete });
    timeline
        .to(piece, {
            x: midX,
            y: startY - arcHeight,
            duration: 0.25,
            ease: "power2.out"
        })
        .to(piece, {
            x: targetX,
            y: targetY,
            duration: 0.25,
            ease: "power2.in"
        });
}
let clickSfx;
// Initialize click sound when main sound system is ready
try {
    clickSfx = new Audio('https://cdn.jsdelivr.net/gh/irustm/pings/ping1.mp3');
} catch (e) {
    console.warn('Could not load click sound file.');
    clickSfx = { play: () => {} };
}

// --- HUD ---
const hud = document.getElementById('hud');
function updateHUD(){
    // Check if current player has any legal moves
    if (hasLegalMoves(state.current)) {
        hud.textContent = state.current.charAt(0).toUpperCase()
                       + state.current.slice(1)
                       + ' to move (turn '+state.moveNumber+')';
    } else {
        // Current player has no legal moves - pass turn
        passTurn();
    }
}

function hasLegalMoves(color) {
    // Check if player can place any pieces
    const myPieces = tray.filter(p => p.meta.color === color && !p.meta.placed);
    if (myPieces.length > 0) {
        // Check if any piece can be legally placed
        for (const piece of myPieces) {
            const zones = legalPlacementZones(color);
            if (zones.size > 0) {
                return true; // Can place at least one piece
            }
        }
    }
    
    // Check if player can move any existing pieces
    const placedPieces = tray.filter(p => p.meta.color === color && p.meta.placed);
    for (const piece of placedPieces) {
        const moves = legalMoveZones(piece);
        if (moves.length > 0) {
            return true; // Can move at least one piece
        }
    }
    
    return false; // No legal moves available
}

function passTurn() {
    console.log(`${state.current} has no legal moves - passing turn`);
    
    // Add pass entry to history
    try {
        const list = document.getElementById('moves-list');
        if (list) {
            const li = document.createElement('li');
            li.className = `history-entry pass-move`;
            const moveNum = state.moveNumber;
            const txt = document.createElement('div');
            txt.className = 'move-text';
            const playerName = state.current.charAt(0).toUpperCase() + state.current.slice(1); // Capitalize first letter
            txt.innerHTML = `<strong>${moveNum}.</strong> ${playerName} pass <em>(no legal moves)</em>`;
            li.appendChild(txt);
            list.appendChild(li);
            
            // Re-center the history panel as content grows
            if (window.layoutHistoryPanel && window.app) {
                window.layoutHistoryPanel(window.app);
            }
            
            // Auto-scroll to bottom
            const historyPanel = document.getElementById('move-history');
            if (historyPanel) {
                historyPanel.scrollTop = historyPanel.scrollHeight;
            }
        }
    } catch (e) {
        console.warn('pass turn history update failed', e);
    }
    
    // Switch turns
    state.moveNumber++;
    state.current = state.current === 'white' ? 'black' : 'white';
    
    // Check if the new current player also has no moves (potential game end)
    setTimeout(() => {
        updateHUD(); // This will recursively check the new player
    }, 100);
}

function clearHighlights(){
    legalZones.forEach(k=>{
        const c=cells.get(k);
        if(c) c.gfx.tint = 0xFFFFFF;
    });
    legalZones.clear();
}

// --- PLACEMENT LOGIC ---
function selectPlacement(piece){
    clearHighlights();
    selected = {piece, mode:'place'};
    legalPlacementZones(piece.meta.color).forEach(k=>{
        const c = cells.get(k);
        if(c){ c.gfx.tint = THEME.highlight; legalZones.add(k); }
    });
    clickSfx.play().catch(()=>{});
}

function legalPlacementZones(color){
    const placed=tray.filter(p=>p.meta.placed);
    const my=placed.filter(p=>p.meta.color===color);
    const occ=new Set(placed.map(p=>`${p.meta.q},${p.meta.r}`));
    const zones=new Set();

    // Queen by turn 4
    const turn = Math.ceil(state.moveNumber / 2);
    if(!state.queenPlaced[color] && turn === 4){
        if(selected.piece.meta.key!=='Q') return zones;
    }

    if(placed.length===0){
        zones.add('0,0');
        return zones;
    }

    // first piece of this color must touch an opponent
    if(my.length===0){
        placed.forEach(p=>{
            if(p.meta.color!==color) DIRS.forEach(d=>{
                const k=`${p.meta.q+d.dq},${p.meta.r+d.dr}`;
                if(cells.has(k)&&!occ.has(k)) zones.add(k);
            });
        });
        return zones;
    }

    // general rule: neighbor to own, no neighbor to opp
    my.forEach(p=>{
        DIRS.forEach(d=>{
            const x=p.meta.q+d.dq, y=p.meta.r+d.dr, k=`${x},${y}`;
            if(!cells.has(k)||occ.has(k)) return;
            const bad=DIRS.some(d2=>{
                const nkey=`${x+d2.dq},${y+d2.dr}`;
                const nc=cells.get(nkey);
                if(!nc||nc.stack.length===0) return false;
                return nc.stack[nc.stack.length-1].meta.color!==color;
            });
            if(!bad) zones.add(k);
        });
    });
    return zones;
}

function commitPlacement(q,r){
    const p = selected.piece; // Move piece reference to function scope
    if (!isNearBorder(q,r)) {
        animating=true;
        p.meta.placed = true;
        p.meta.q = q; p.meta.r = r;
        if(p.meta.key==='Q') state.queenPlaced[p.meta.color] = true;

        // Play placement sound
        if (window.playSound) {
            window.playSound('placement');
        }

        const cell = cells.get(`${q},${r}`);
        cell.stack.push(p);
        const base=axialToPixel(q,r);
        cell.stack.forEach((c,i)=>{
            c.x = base.x;
            c.y = base.y - i*6;
            pieceLayer.setChildIndex(c,
                pieceLayer.children.length - cell.stack.length + i
            );
        });

        animating=false;
        state.moveNumber++;
        state.current = state.current==='white'?'black':'white';
        updateHUD();
    }
    // win check: check both players for surrounded queens
    const winner = checkForWinner();
    if (winner) {
        state.gameOver = true;
        setTimeout(() => {
            const banner = window.winBanner;
            if (banner) {
                if (winner === 'DRAW') {
                    banner.text = `GAME OVER - DRAW!`;
                } else {
                    banner.text = `GAME OVER - ${winner.toUpperCase()} WINS!`;
                }
                banner.visible = true;
            } else {
                console.log(`GAME OVER - ${winner === 'DRAW' ? 'DRAW' : winner.toUpperCase() + ' WINS'}!`);
                alert(`GAME OVER - ${winner === 'DRAW' ? 'DRAW' : winner.toUpperCase() + ' WINS'}!`);
            }
        }, 100);
    }
    // update move history UI (use p which is the placed piece)
    try{
        const list = document.getElementById('moves-list');
        if(list){
            const li = document.createElement('li');
            li.className = `history-entry ${p.meta.color}-move`;
            const mini = buildMiniPathSVG([[q,r]], p.meta.key, p.meta.color); // single dot for placement
            const label = labelFromCenter(q,r);
            const moveNum = Math.max(1, state.moveNumber - 1);
            const txt = document.createElement('div'); txt.className='move-text';
            
            // Remove color from text since we now use visual indicators
            txt.innerHTML = `<strong>${moveNum}.</strong> ${getPieceFullName(p.meta.key)} placed at ${label} <span style="opacity:0.7">(${q},${r})</span>`;
            
            li.appendChild(mini);
            li.appendChild(txt);
            li.addEventListener('mouseenter', ()=> showOrientationOverlay(q,r));
            li.addEventListener('mouseleave', ()=> hideOrientationOverlay());
            list.appendChild(li);
            
            // Re-center the history panel as content grows
            if (window.layoutHistoryPanel && window.app) {
                window.layoutHistoryPanel(window.app);
            }
            
            // Auto-scroll to bottom to show latest move
            const historyPanel = document.getElementById('move-history');
            if(historyPanel) {
                historyPanel.scrollTop = historyPanel.scrollHeight;
            }
        }
    }catch(e){console.warn('move history update failed', e);} 

    clearHighlights();
    layoutTray(app);
    selected = null;
    clickSfx.play().catch(()=>{});
}

function checkSurrounded(color) {
    console.log(`Checking if ${color} queen is surrounded...`);
    const queen = tray.find(p =>
        p.meta.key === 'Q' &&
        p.meta.color === color &&
        p.meta.placed
    );
    if (!queen) {
        console.log('Queen not found on board.');
        return false;
    }

    const { q, r } = queen.meta;
    console.log(`Queen found at ${q},${r}`);
    return DIRS.every(d => {
        const key = `${q + d.dq},${r + d.dr}`;
        const cell = cells.get(key);
        const isOccupied = cell && cell.stack.length > 0;
        console.log(`  Checking neighbor ${key}: ${isOccupied ? 'Occupied' : 'Empty'}`);
        return isOccupied;
    });
}

function checkForWinner() {
    const whiteSurrounded = checkSurrounded('white');
    const blackSurrounded = checkSurrounded('black');
    
    // Both queens surrounded = draw (rules say game is drawn in this case)
    if (whiteSurrounded && blackSurrounded) {
        return 'DRAW';
    }
    
    // One queen surrounded = opposite color wins
    if (whiteSurrounded) return 'black';
    if (blackSurrounded) return 'white';
    
    // No one surrounded = game continues
    return null;
}

// --- MOVE LOGIC ---
function selectMove(piece) {
    console.log('--- SELECT MOVE ---');
    if (!state.queenPlaced[piece.meta.color]) return;

    if (selected && selected.piece === piece) {
        clearHighlights();
        selected = null;
        tray.forEach(p => p.interactive = true);
        clickSfx.play().catch(() => {});
        return;
    }

    clearHighlights();
    selected = { piece, mode: 'move' };

    const moves = legalMoveZones(piece);
    if (moves.length === 0) {
        selected = null;
        tray.forEach(p => p.interactive = true);
        clickSfx.play().catch(() => {});
        return;
    }

    tray.forEach(p => { if (p !== piece) p.interactive = false; });
    moves.forEach(k => {
        const c = cells.get(k);
        if (c) {
            c.gfx.tint = THEME.highlight;
            legalZones.add(k);
        }
    });
    clickSfx.play().catch(() => {});
}

function isHiveConnected(set){
    if(set.size<2) return true;
    const arr=Array.from(set),
            seen=new Set([arr[0]]),
            q=[arr[0]];
    while(q.length){
        const cur=q.shift(),
              [x,y]=cur.split(',').map(Number);
        DIRS.forEach(d=>{
            const nb=`${x+d.dq},${y+d.dr}`;
            if(set.has(nb)&&!seen.has(nb)){
                seen.add(nb);
                q.push(nb);
            }
        });
    }
    return seen.size===set.size;
}

// simulate removing a piece at (fx,fr) and placing it at (tx,tr)
// return true if the resulting occupied tile set remains connected
function wouldHiveRemainConnectedAfterMove(fx,fr,tx,tr){
    const fromKey = `${fx},${fr}`;
    const toKey = `${tx},${tr}`;
    const occ = new Set();
    // build occupancy from actual cell stacks
    cells.forEach((c, key) => { if (c && c.stack && c.stack.length > 0) occ.add(key); });
    const fromCell = cells.get(fromKey);
    // simulate removal: if the origin cell becomes empty, delete it
    if (!fromCell || !fromCell.stack || fromCell.stack.length <= 1) {
        occ.delete(fromKey);
    }
    // simulate placement: if destination was empty, add it
    const toCell = cells.get(toKey);
    if (!toCell || !toCell.stack || toCell.stack.length === 0) {
        occ.add(toKey);
    }
    return isHiveConnected(occ);
}

function canSlide(fx,fr,tx,tr,occ){
    const dq=tx-fx, dr=tr-fr;
    const idx=DIRS.findIndex(d=>d.dq===dq&&d.dr===dr);
    const i1=(idx+5)%6, i2=(idx+1)%6;
    const s1=`${fx+DIRS[i1].dq},${fr+DIRS[i1].dr}`,
            s2=`${fx+DIRS[i2].dq},${fr+DIRS[i2].dr}`;
    return !(occ.has(s1)&&occ.has(s2));
}

function hiveIntactAfterRemoval(q, r) {
    const k = `${q},${r}`;
    const cell = cells.get(k);
    // if origin cell is empty, nothing to remove
    if (!cell || !cell.stack || cell.stack.length === 0) return true;
    // build occupancy from actual cell stacks so stacking is respected
    const occ = new Set();
    cells.forEach((c, key) => {
        if (c && c.stack && c.stack.length > 0) occ.add(key);
    });
    // simulate removal: if the origin cell only had one piece, it becomes empty
    if (cell.stack.length === 1) occ.delete(k);
    return isHiveConnected(occ);
}

function legalMoveZones(piece){
    const type=piece.meta.key,
            q0=piece.meta.q,
            r0=piece.meta.r;
    // build occupancy from actual cell stacks so stacking is respected
    const occAll = new Set();
    cells.forEach((c, key) => { if (c && c.stack && c.stack.length > 0) occAll.add(key); });
    const occRem = new Set(occAll);
    // simulate removal: only delete the origin key if it will become empty
    const originKey = `${q0},${r0}`;
    const originCell = cells.get(originKey);
    if (!originCell || !originCell.stack || originCell.stack.length <= 1) {
        occRem.delete(originKey);
    }

    if(!hiveIntactAfterRemoval(q0, r0)) return [];

    const zones=new Set();

    if(type==='B'){
        DIRS.forEach(d=>{
            const x=q0+d.dq, y=r0+d.dr, k=`${x},${y}`;
            if(cells.has(k) && wouldHiveRemainConnectedAfterMove(q0,r0,x,y)) zones.add(k);
        });
    }
    else if(type==='Q'){
        DIRS.forEach(d=>{
            const x=q0+d.dq, y=r0+d.dr, k=`${x},${y}`;
            if(cells.has(k)
               && !occAll.has(k)
               && canSlide(q0,r0,x,y,occRem)
               && wouldHiveRemainConnectedAfterMove(q0,r0,x,y)
            ) zones.add(k);
        });
    }
    else if(type==='G'){
        DIRS.forEach(d=>{
            let x=q0+d.dq, y=r0+d.dr, jumped=0;
            while(occAll.has(`${x},${y}`)){
                jumped++;
                x+=d.dq; y+=d.dr;
            }
            const k=`${x},${y}`;
            if(jumped>0 && cells.has(k) && !occAll.has(k) && wouldHiveRemainConnectedAfterMove(q0,r0,x,y)) zones.add(k);
        });
    }
    else if(type==='A'){
        const queue=[[q0,r0]], vis=new Set();
        while(queue.length){
            const [cx,cy]=queue.shift();
            DIRS.forEach(d=>{
                const nx=cx+d.dq, ny=cy+d.dr, k=`${nx},${ny}`;
                if(!cells.has(k)
                   || occRem.has(k)
                   || vis.has(k)
                   || !canSlide(cx,cy,nx,ny,occRem)
                ) return;
                // ensure making this move would not break the hive
                if(!wouldHiveRemainConnectedAfterMove(q0,r0,nx,ny)) return;
                vis.add(k);
                queue.push([nx,ny]);
                zones.add(k);
            });
        }
    }
    else if(type==='S'){
        return getSpiderMoves(q0, r0);
    }

    return Array.from(zones);
}

function getSpiderMoves(q0, r0) {
    // Spider must move exactly 3 spaces around the hive perimeter
    // Follow Hive rules: exactly 3 steps, no backtracking, stay in contact with hive
    
    if (!hiveIntactAfterRemoval(q0, r0)) return [];

    const startKey = `${q0},${r0}`;
    const cell = cells.get(startKey);
    const occAll = new Set();
    cells.forEach((c, key) => { if (c && c.stack && c.stack.length > 0) occAll.add(key); });
    const occRem = new Set(occAll);
    if (!cell || !cell.stack || cell.stack.length <= 1) {
        occRem.delete(startKey);
    }

    const paths = [];
    
    // Find all empty spaces adjacent to the spider
    for(const dir of DIRS) {
        const startQ = q0 + dir.dq;
        const startR = r0 + dir.dr;
        const startKey = `${startQ},${startR}`;
        
        // Must be empty and on the board
        if(!cells.has(startKey) || occRem.has(startKey)) continue;
        
        // Must be adjacent to the hive after spider removal
        const isAdjacentToHive = DIRS.some(d => occRem.has(`${startQ + d.dq},${startR + d.dr}`));
        if(!isAdjacentToHive) continue;
        
        // Spider must be able to slide to this position
        if(!canSlide(q0, r0, startQ, startR, occRem)) continue;
        
        // Try to build a 3-step path from this starting position
        const path = buildSpiderPath(q0, r0, startQ, startR, occRem);
        if(path) {
            paths.push(path);
        }
    }
    
    console.log(`🕷️ Spider at (${q0},${r0}) found ${paths.length} valid paths:`, 
        paths.map(p => p.map(step => `(${step[0]},${step[1]})`).join(' → ')));
    return paths;
}

function buildSpiderPath(spiderQ, spiderR, startQ, startR, occRem) {
    const path = [[spiderQ, spiderR], [startQ, startR]];
    let currentQ = startQ, currentR = startR;
    const visited = new Set([`${spiderQ},${spiderR}`, `${startQ},${startR}`]);
    
    // Complete exactly 2 more steps (total of 3)
    for(let step = 2; step <= 3; step++) {
        let found = false;
        
        // Look for next valid position around the hive perimeter
        for(const dir of DIRS) {
            const nextQ = currentQ + dir.dq;
            const nextR = currentR + dir.dr;
            const nextKey = `${nextQ},${nextR}`;
            
            // Skip if out of bounds, occupied, or already visited
            if(!cells.has(nextKey) || occRem.has(nextKey) || visited.has(nextKey)) continue;
            
            // Must be adjacent to hive
            const isAdjacentToHive = DIRS.some(d => occRem.has(`${nextQ + d.dq},${nextR + d.dr}`));
            if(!isAdjacentToHive) continue;
            
            // Must be able to slide to this position
            if(!canSlide(currentQ, currentR, nextQ, nextR, occRem)) continue;
            
            // Found a valid next position
            path.push([nextQ, nextR]);
            visited.add(nextKey);
            currentQ = nextQ;
            currentR = nextR;
            found = true;
            break;
        }
        
        if(!found) return null; // Cannot complete 3-step path
    }
    
    return path;
}
    // build occRem from current cells and simulate removal of the spider piece
    const occAll = new Set();
    cells.forEach((c, key) => { if (c && c.stack && c.stack.length > 0) occAll.add(key); });
    const occRem = new Set(occAll);
    if (!cell || !cell.stack || cell.stack.length <= 1) {
        occRem.delete(startKey);
    }

    // collect perimeter candidates: empty cells adjacent to occRem
    const perimeter = new Map(); // key -> {q,r,x,y}
    let cx = 0, cy = 0, count = 0;
    occRem.forEach(k => {
        const [oq,or] = k.split(',').map(Number);
        const pt = axialToPixel(oq,or);
        cx += pt.x; cy += pt.y; count++;
    });
    if(count===0) return [];
    cx /= count; cy /= count;

    occRem.forEach(k=>{}); // no-op to keep parity

    // build perimeter set
    occRem.forEach(k=>{});
    occRem.forEach(o => {});

    // iterate neighborhood around occupied cells
    occRem.forEach(k => {
        const [oq,or] = k.split(',').map(Number);
        DIRS.forEach(d => {
            const nq = oq + d.dq, nr = or + d.dr;
            const nk = `${nq},${nr}`;
            if(!cells.has(nk)) return;
            if(occRem.has(nk)) return;
            // ensure it touches hive (by virtue of adjacency above)
            if(!perimeter.has(nk)){
                const p = axialToPixel(nq,nr);
                perimeter.set(nk, {q:nq,r:nr,x:p.x,y:p.y});
            }
        });
    });

    if(perimeter.size===0) return [];

    // sort by angle around centroid
    const arr = Array.from(perimeter.entries()).map(([k,v])=>{
        const angle = Math.atan2(v.y - cy, v.x - cx);
        return {key:k, angle, ...v};
    });
    arr.sort((a,b)=>a.angle - b.angle);
    const ring = arr.map(a=>a.key);

    // helper to verify a 3-step walk along the ring starting at index and stepDir
    function validateWalkFrom(startIdx, stepDir){
        const n = ring.length;
        let curQ = q0, curR = r0;
        for(let s=1;s<=3;s++){
            // first step should be the originNeighbor (startIdx), then startIdx+stepDir, etc.
            const idx = (startIdx + (s-1)*stepDir + n) % n;
            const [nx,ny] = ring[idx].split(',').map(Number);
            // step must be to an adjacent hex
            const neigh = DIRS.some(d=>curQ + d.dq === nx && curR + d.dr === ny);
            if(!neigh) return null;
            if(!canSlide(curQ,curR,nx,ny,occRem)) return null;
            // next hex must touch hive
            if(!DIRS.some(d=>occRem.has(`${nx + d.dq},${ny + d.dr}`))) return null;
            curQ = nx; curR = ny;
        }
        return `${curQ},${curR}`;
    }

    // find perimeter neighbors that touch the origin
    const originNeighbors = [];
    for(let i=0;i<DIRS.length;i++){
        const nx = q0 + DIRS[i].dq, ny = r0 + DIRS[i].dr;
        const k = `${nx},${ny}`;
        if(perimeter.has(k)) originNeighbors.push(k);
    }

    const endpoints = new Set();
    const n = ring.length;

    // Try each origin neighbor as a start; pick the first start that yields
    // a valid 3-step walk in each direction. This ensures the spider 'hugs'
    // the hive and never backtracks.
    let found = { cw: null, ccw: null, startIdxCW: null, startIdxCCW: null };
    for(const startKey of originNeighbors){
        const startIdx = ring.indexOf(startKey);
        if(startIdx === -1) continue;
        if(!found.ccw){
            const ep = validateWalkFrom(startIdx, +1);
            if(ep){ found.ccw = ep; found.startIdxCCW = startIdx; endpoints.add(ep); }
        }
        if(!found.cw){
            const ep = validateWalkFrom(startIdx, -1);
            if(ep){ found.cw = ep; found.startIdxCW = startIdx; endpoints.add(ep); }
        }
        if(found.cw && found.ccw) break;
    }

    function finalFromStart(startIdx, stepDir){
        let last = null;
        for(let s=1;s<=3;s++){
            const idx = (startIdx + (s-1)*stepDir + n) % n;
            last = ring[idx];
        }
        return last;
    }

    // If only one direction had a strict path, include the theoretical
    // opposite endpoint computed from that working start index so both
    // directions are shown when the spider is not trapped.
    if(found.cw && !found.ccw && found.startIdxCW !== null){
        endpoints.add(finalFromStart(found.startIdxCW, +1));
    }
    if(found.ccw && !found.cw && found.startIdxCCW !== null){
        endpoints.add(finalFromStart(found.startIdxCCW, -1));
    }

    // Fallback: if endpoints empty, try original neighbor-index walker as a last resort
    if(endpoints.size===0){
        // previous simple walker: try starting at any adjacent empty cell and step by neighbor index
        function neighborIndex(fromQ, fromR, toQ, toR){
            for(let i=0;i<DIRS.length;i++){
                if(fromQ+DIRS[i].dq===toQ && fromR+DIRS[i].dr===toR) return i;
            }
            return -1;
        }
        function walkDirection(dirStep){
            let q=q0, r=r0;
            // find any neighbor index that touches the hive
            let startIdx = -1;
            for(let i=0;i<6;i++){
                const nx = q + DIRS[i].dq, ny = r + DIRS[i].dr;
                const k = `${nx},${ny}`;
                if(!cells.has(k) || occRem.has(k)) continue;
                if(DIRS.some(d=>occRem.has(`${nx + d.dq},${ny + d.dr}`))){ startIdx = i; break; }
            }
            if(startIdx === -1) return null;
            let idx = startIdx;
            for(let step=0; step<3; step++){
                idx = (idx + dirStep + 6) % 6;
                const nx = q + DIRS[idx].dq, ny = r + DIRS[idx].dr;
                const k = `${nx},${ny}`;
                if(!cells.has(k) || occRem.has(k)) return null;
                if(!canSlide(q,r,nx,ny,occRem)) return null;
                if(!DIRS.some(d=>occRem.has(`${nx + d.dq},${ny + d.dr}`))) return null;
                const common = DIRS.some(d2=>{
                    const a = `${q + d2.dq},${r + d2.dr}`;
                    const b = `${nx + d2.dq},${ny + d2.dr}`;
                    return occRem.has(a) && occRem.has(b);
                });
                if(!common) return null;
                q = nx; r = ny;
            }
            return `${q},${r}`;
        }
        const cw = walkDirection(+1);
        const ccw = walkDirection(-1);
        if(cw) endpoints.add(cw);
        if(ccw) endpoints.add(ccw);
    }

    return Array.from(endpoints);
}

function commitMove(q,r){
    animating=true;
    const p=selected.piece;
    if (occAllParam) {
        occAll = new Set(occAllParam);
    } else {
        // build occupancy from actual cell stacks like other functions
        occAll = new Set();
        cells.forEach((c, key) => { if (c && c.stack && c.stack.length > 0) occAll.add(key); });
    }
    // remove the spider itself (it must move)
    occAll.delete(startKey);
    if(!isHiveConnected(occAll)) return [];

    const occRem = new Set(occAll);

    // collect perimeter empty hexes
    const perimeter = new Map();
    let cx=0, cy=0, count=0;
    occRem.forEach(k=>{
        const [oq,or] = k.split(',').map(Number);
        const p = axialToPixel(oq,or); cx += p.x; cy += p.y; count++;
    });
    if(count===0) return [];
    cx/=count; cy/=count;
    occRem.forEach(k=>{
        const [oq,or] = k.split(',').map(Number);
        DIRS.forEach(d=>{
            const nq=oq+d.dq, nr=or+d.dr, nk=`${nq},${nr}`;
            if(!cells.has(nk)) return; if(occRem.has(nk)) return;
            if(!perimeter.has(nk)) perimeter.set(nk, {q:nq,r:nr,x:axialToPixel(nq,nr).x,y:axialToPixel(nq,nr).y});
        });
    });
    if(perimeter.size===0) return [];
    
    // Build proper connected perimeter ring
    const ring = [];
    const used = new Set();
    
    // Find starting position (any perimeter position)
    const perimKeys = Array.from(perimeter.keys());
    if(perimKeys.length === 0) return [];
    
    let current = perimKeys[0];
    ring.push(current);
    used.add(current);
    
    // Build ring by following adjacent connections
    while(ring.length < perimeter.size) {
        const [curQ, curR] = current.split(',').map(Number);
        let found = false;
        
        // Look for adjacent perimeter position we haven't used
        for(const dir of DIRS) {
            const nextQ = curQ + dir.dq;
            const nextR = curR + dir.dr;
            const nextKey = `${nextQ},${nextR}`;
            
            if(perimeter.has(nextKey) && !used.has(nextKey)) {
                ring.push(nextKey);
                used.add(nextKey);
                current = nextKey;
                found = true;
                break;
            }
        }
        
        // If no adjacent position found, the perimeter is disconnected
        // This shouldn't happen in a valid Hive game, so we'll stop here
        if(!found) {
            console.log(`🐛 Warning: Disconnected perimeter at ${current}, stopping ring construction`);
            break;
        }
    }
    
    console.log(`🕷️ Spider at (${q0},${r0}) - Perimeter ring:`, ring);

    const n = ring.length;
    function buildPathFrom(startIdx, stepDir){
        // Build a 3-step spider path following perimeter in given direction
        // First step is from spider position to the starting perimeter position
        const [firstQ, firstR] = ring[startIdx].split(',').map(Number);
        const path=[[q0,r0], [firstQ, firstR]];
        let curQ=firstQ, curR=firstR;
        let curIdx = startIdx;
        const visited = new Set([`${q0},${r0}`, `${firstQ},${firstR}`]);
        
        console.log(`🐛 Building spider path from ring[${startIdx}]=${ring[startIdx]}, stepDir=${stepDir}`);
        console.log(`🐛   Step 1: (${q0},${r0}) → (${firstQ},${firstR}) [ring[${startIdx}]]`);
        
        // Validate first step (spider to perimeter)
        if(!canSlide(q0,r0,firstQ,firstR,occRem)) {
            console.log(`🐛   ❌ Cannot slide from (${q0},${r0}) to (${firstQ},${firstR})`);
            return null;
        }
        if(!DIRS.some(d=>occRem.has(`${firstQ + d.dq},${firstR + d.dr}`))) {
            console.log(`🐛   ❌ Target (${firstQ},${firstR}) not adjacent to hive`);
            return null;
        }
        console.log(`🐛   ✅ Valid step`);
        
        // Continue with 2 more steps around perimeter
        for(let s=2;s<=3;s++){
            // Move to next position in perimeter ring
            curIdx = (curIdx + stepDir + ring.length) % ring.length;
            const [nx,ny] = ring[curIdx].split(',').map(Number);
            const posKey = `${nx},${ny}`;
            
            console.log(`🐛   Step ${s}: (${curQ},${curR}) → (${nx},${ny}) [ring[${curIdx}]]`);
            
            // Check if we've already visited this position
            if(visited.has(posKey)) {
                console.log(`🐛   ❌ Already visited position (${nx},${ny})`);
                return null;
            }
            
            // Validate the move
            if(!canSlide(curQ,curR,nx,ny,occRem)) {
                console.log(`🐛   ❌ Cannot slide from (${curQ},${curR}) to (${nx},${ny})`);
                return null;
            }
            if(!DIRS.some(d=>occRem.has(`${nx + d.dq},${ny + d.dr}`))) {
                console.log(`🐛   ❌ Target (${nx},${ny}) not adjacent to hive`);
                return null;
            }
            
            console.log(`🐛   ✅ Valid step`);
            path.push([nx,ny]);
            visited.add(posKey);
            curQ=nx; curR=ny;
        }
        
        console.log(`🐛 Final path:`, path);
        
        // Spider moves exactly 3 steps around the perimeter - final distance doesn't matter
        const finalQ = path[3][0];
        const finalR = path[3][1];
        console.log(`🐛   ✅ Spider completed 3-step perimeter move to (${finalQ},${finalR})`);
        return path;
    }

    // find origin neighbors on perimeter
    const originNeighbors=[];
    for(let i=0;i<DIRS.length;i++){ 
        const nx=q0+DIRS[i].dq, ny=r0+DIRS[i].dr, k=`${nx},${ny}`; 
        if(perimeter.has(k)) originNeighbors.push(k); 
    }
    
    console.log(`🕷️ Spider neighbors: ${DIRS.map((d,i) => `${i}:(${q0+d.dq},${r0+d.dr})`).join(', ')}`);
    console.log(`🕷️ Origin neighbors on perimeter:`, originNeighbors);

    const paths = [];
    let found={cw:null,ccw:null,startIdxCW:null,startIdxCCW:null};
    for(const sk of originNeighbors){
        const startIdx = ring.indexOf(sk); if(startIdx===-1) continue;
        console.log(`🔍 Trying origin neighbor ${sk} at ring index ${startIdx}`);
        
        // Try CCW direction
        const pathCCW = buildPathFrom(startIdx, +1); 
        if(pathCCW){ 
            const finalPos = pathCCW[3];
            console.log(`✅ Found CCW path from ${sk} to (${finalPos[0]},${finalPos[1]})`);
            paths.push(pathCCW);
            if(!found.ccw) { found.ccw=pathCCW; found.startIdxCCW=startIdx; }
        } else {
            console.log(`❌ No CCW path from ${sk}`);
        }
        
        // Try CW direction
        const pathCW = buildPathFrom(startIdx, -1); 
        if(pathCW){ 
            const finalPos = pathCW[3];
            console.log(`✅ Found CW path from ${sk} to (${finalPos[0]},${finalPos[1]})`);
            paths.push(pathCW);
            if(!found.cw) { found.cw=pathCW; found.startIdxCW=startIdx; }
        } else {
            console.log(`❌ No CW path from ${sk}`);
        }
    }

    // Simple approach: only return actually validated paths
    // The geometric constraint should naturally provide 2 paths in most cases
    
    // Remove duplicate paths (can happen when both directions find same sequence)
    const uniquePaths = [];
    for(const path of paths) {
        const pathStr = path.map(step => `${step[0]},${step[1]}`).join('→');
        if(!uniquePaths.some(existing => 
            existing.map(step => `${step[0]},${step[1]}`).join('→') === pathStr)) {
            uniquePaths.push(path);
        }
    }
    
    console.log(`🕷️ Spider at (${q0},${r0}) found ${uniquePaths.length} valid paths:`, 
        uniquePaths.map(p => p.map(step => `(${step[0]},${step[1]})`).join(' → ')));
    return uniquePaths;
}

function commitMove(q,r){
    animating=true;
    const p=selected.piece;
    // capture occupancy prior to move (includes the moving piece at its old position)
    const occBefore = new Set(tray.filter(p2=>p2.meta.placed).map(p2=>`${p2.meta.q},${p2.meta.r}`));
    const oldKey=`${p.meta.q},${p.meta.r}`,
            oldCell=cells.get(oldKey);
    
    // Store original position for animation BEFORE modifying the board
    const fromQ = p.meta.q;
    const fromR = p.meta.r;
    
    const ix=oldCell.stack.indexOf(p);
    if(ix>=0) oldCell.stack.splice(ix,1);

    oldCell.stack.forEach((c,i)=>{
        const rel=axialToPixel(oldCell.q,oldCell.r);
        c.x = rel.x;
        c.y = rel.y - i*6;
    });

    const cell=cells.get(`${q},${r}`);
    cell.stack.push(p);

    // Use piece-specific animation with the original board state
    animatePieceMovement(p, fromQ, fromR, q, r, occBefore, () => {
        const rel=axialToPixel(q,r);
        cell.stack.forEach((c,i)=>{
            c.x = rel.x;
            c.y = rel.y - i*6;
            pieceLayer.setChildIndex(c,
                pieceLayer.children.length-cell.stack.length+i
            );
        });

        p.meta.q=q; p.meta.r=r;

        animating=false;
        state.moveNumber++;
        state.current = state.current==='white'?'black':'white';
        updateHUD();

        const winner = checkForWinner();
        if (winner) {
            state.gameOver = true;
            setTimeout(() => {
                const banner = window.winBanner;
                if (banner) {
                    if (winner === 'DRAW') {
                        banner.text = `GAME OVER - DRAW!`;
                    } else {
                        banner.text = `GAME OVER - ${winner.toUpperCase()} WINS!`;
                    }
                    banner.visible = true;
                } else {
                    console.log(`GAME OVER - ${winner === 'DRAW' ? 'DRAW' : winner.toUpperCase() + ' WINS'}!`);
                    alert(`GAME OVER - ${winner === 'DRAW' ? 'DRAW' : winner.toUpperCase() + ' WINS'}!`);
                }
            }, 100);
        }

        clearHighlights();
        selected = null;
        tray.forEach(p2=>p2.interactive = true);
        if (clickSfx && clickSfx.play) {
            clickSfx.play().catch(()=>{});
        }

        // add to move history
        try{
            const list = document.getElementById('moves-list');
            if(list){
                const li = document.createElement('li');
                li.className = `history-entry ${p.meta.color}-move`;
                const moveNum = Math.max(1, state.moveNumber - 1);
                const oldLabel = labelFromCenter(fromQ, fromR);
                const newLabel = labelFromCenter(q, r);
                const txt = document.createElement('div'); txt.className='move-text';
                
                // Remove color from text since we now use visual indicators
                txt.innerHTML = `<strong>${moveNum}.</strong> ${getPieceFullName(p.meta.key)} moves ${oldLabel} <span style="opacity:0.7">(${fromQ},${fromR})</span> → ${newLabel} <span style="opacity:0.7">(${q},${r})</span>`;
                
                // Build visual path
                let pathForVisual = [[fromQ, fromR], [q, r]]; // default: simple line
                
                // For spider, try to show actual path taken
                if(p.meta.key === 'S') {
                    const spiderPaths = getSpiderPaths(fromQ, fromR);
                    if(spiderPaths && spiderPaths.length > 0) {
                        // Find the path that ends at the destination
                        for (const path of spiderPaths) {
                            const lastStep = path[path.length - 1];
                            if (lastStep[0] === q && lastStep[1] === r) {
                                pathForVisual = path;
                                break;
                            }
                        }
                    }
                }
                
                const mini = buildMiniPathSVG(pathForVisual, p.meta.key, p.meta.color);
                li.appendChild(mini);
                li.appendChild(txt);
                li.addEventListener('mouseenter', ()=> showOrientationOverlay(p.meta.q, p.meta.r));
                li.addEventListener('mouseleave', ()=> hideOrientationOverlay());
                list.appendChild(li);
                
                // Re-center the history panel after adding content
                if (window.layoutHistoryPanel && window.app) {
                    window.layoutHistoryPanel(window.app);
                }
                
                // Auto-scroll to bottom to show latest move
                const historyPanel = document.getElementById('move-history');
                if(historyPanel) {
                    historyPanel.scrollTop = historyPanel.scrollHeight;
                }
            }
        }catch(e){console.warn('move history update failed', e);} 
    });
}

// Build a tiny SVG visual showing a path (array of [q,r]) scaled to mini box
function buildMiniPathSVG(path, pieceKey = null, color = null){
    const ns = 'http://www.w3.org/2000/svg';
    const w = 80, h = 36;
    const svg = document.createElementNS(ns,'svg');
    svg.setAttribute('width', w); 
    svg.setAttribute('height', h);
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    svg.className = 'mini-path';
    
    // Map axial to local x,y in the mini box
    const pts = path.map(([q,r])=>{
        const p = axialToPixel(q,r);
        return {x:p.x, y:p.y, q, r};
    });
    
    // Normalize coordinates to fit within the SVG bounds
    const minx = Math.min(...pts.map(p=>p.x)), maxx = Math.max(...pts.map(p=>p.x));
    const miny = Math.min(...pts.map(p=>p.y)), maxy = Math.max(...pts.map(p=>p.y));
    const pad = 6;
    const spanx = Math.max(1, maxx-minx), spany = Math.max(1, maxy-miny);
    
    // Color scheme based on player
    const strokeColor = color === 'white' ? 'rgba(240,240,240,0.8)' : 'rgba(100,100,100,0.8)';
    const fillColor = color === 'white' ? 'rgba(255,255,255,0.9)' : 'rgba(80,80,80,0.9)';
    const accentColor = color === 'white' ? '#f0f0f0' : '#555';
    
    // Convert points to SVG coordinates
    const svgPts = pts.map((p,i)=>{
        const nx = pad + ((p.x-minx)/spanx)*(w-2*pad);
        const ny = pad + ((p.y-miny)/spany)*(h-2*pad);
        return {x: nx, y: ny, originalQ: p.q, originalR: p.r};
    });
    
    // For placement moves (single point), show a special indicator
    if (pts.length === 1) {
        const center = svgPts[0];
        
        // Background circle
        const bg = document.createElementNS(ns,'circle');
        bg.setAttribute('cx', center.x); 
        bg.setAttribute('cy', center.y); 
        bg.setAttribute('r', 8);
        bg.setAttribute('fill', 'rgba(0,100,0,0.2)');
        bg.setAttribute('stroke', 'rgba(0,150,0,0.6)');
        bg.setAttribute('stroke-width', '1.5');
        svg.appendChild(bg);
        
        // Piece indicator
        const piece = document.createElementNS(ns,'circle');
        piece.setAttribute('cx', center.x); 
        piece.setAttribute('cy', center.y); 
        piece.setAttribute('r', 4);
        piece.setAttribute('fill', fillColor);
        svg.appendChild(piece);
        
        // Add piece type letter
        if (pieceKey) {
            const text = document.createElementNS(ns,'text');
            text.setAttribute('x', center.x);
            text.setAttribute('y', center.y + 2);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '8');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', color === 'white' ? '#333' : '#fff');
            text.textContent = pieceKey;
            svg.appendChild(text);
        }
        
        return svg;
    }
    
    // For movement, draw enhanced path visualization
    if (svgPts.length > 1) {
        // Draw the path with improved styling
        for (let i = 1; i < svgPts.length; i++) {
            const prev = svgPts[i-1];
            const curr = svgPts[i];
            
            // Draw path line with gradient effect
            const line = document.createElementNS(ns,'line');
            line.setAttribute('x1', prev.x); 
            line.setAttribute('y1', prev.y);
            line.setAttribute('x2', curr.x); 
            line.setAttribute('y2', curr.y);
            line.setAttribute('stroke', strokeColor); 
            line.setAttribute('stroke-width', i === svgPts.length - 1 ? '3' : '2');
            line.setAttribute('stroke-linecap', 'round');
            if (i === svgPts.length - 1) {
                line.setAttribute('stroke-dasharray', '2,1');
            }
            svg.appendChild(line);
            
            // Add step indicators for multi-step moves (like spider)
            if (svgPts.length > 2 && i < svgPts.length - 1) {
                const stepCircle = document.createElementNS(ns,'circle');
                stepCircle.setAttribute('cx', curr.x); 
                stepCircle.setAttribute('cy', curr.y); 
                stepCircle.setAttribute('r', 2);
                stepCircle.setAttribute('fill', accentColor);
                stepCircle.setAttribute('stroke', 'rgba(255,255,255,0.3)');
                stepCircle.setAttribute('stroke-width', '1');
                svg.appendChild(stepCircle);
            }
        }
        
        // Draw start position
        const start = svgPts[0];
        const startCircle = document.createElementNS(ns,'circle');
        startCircle.setAttribute('cx', start.x); 
        startCircle.setAttribute('cy', start.y); 
        startCircle.setAttribute('r', 4);
        startCircle.setAttribute('fill', fillColor);
        startCircle.setAttribute('stroke', accentColor);
        startCircle.setAttribute('stroke-width', '1.5');
        svg.appendChild(startCircle);
        
        // Draw end position with directional arrow
        const end = svgPts[svgPts.length - 1];
        const prev = svgPts[svgPts.length - 2];
        
        // Calculate arrow direction
        const dx = end.x - prev.x;
        const dy = end.y - prev.y;
        const angle = Math.atan2(dy, dx);
        
        // End circle
        const endCircle = document.createElementNS(ns,'circle');
        endCircle.setAttribute('cx', end.x); 
        endCircle.setAttribute('cy', end.y); 
        endCircle.setAttribute('r', 5);
        endCircle.setAttribute('fill', fillColor);
        endCircle.setAttribute('stroke', accentColor);
        endCircle.setAttribute('stroke-width', '2');
        svg.appendChild(endCircle);
        
        // Directional arrow
        const arrowSize = 6;
        const arrowX1 = end.x - Math.cos(angle - 0.5) * arrowSize;
        const arrowY1 = end.y - Math.sin(angle - 0.5) * arrowSize;
        const arrowX2 = end.x - Math.cos(angle + 0.5) * arrowSize;
        const arrowY2 = end.y - Math.sin(angle + 0.5) * arrowSize;
        
        const arrow = document.createElementNS(ns,'polygon');
        arrow.setAttribute('points', `${end.x},${end.y} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
        arrow.setAttribute('fill', accentColor);
        svg.appendChild(arrow);
        
        // Add piece type indicator at start
        if (pieceKey) {
            const text = document.createElementNS(ns,'text');
            text.setAttribute('x', start.x);
            text.setAttribute('y', start.y + 2);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '6');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', color === 'white' ? '#222' : '#fff');
            text.textContent = pieceKey;
            svg.appendChild(text);
        }
    }
    
    return svg;
}

// Simple straight-line splitter for path fallback: returns start, mid, end as q,r arrays
function computeStraightPath(startKey, endKey){
    const [sq,sr]=startKey.split(',').map(Number);
    const [eq,er]=endKey.split(',').map(Number);
    // try to divide into 3 steps by linear interpolation on cube coords
    const a = axialToCube(sq,sr), b = axialToCube(eq,er);
    const res = [];
    for(let t=0;t<=3;t++){
        const x = Math.round(lerp(a.x,b.x,t/3));
        const y = Math.round(lerp(a.y,b.y,t/3));
        const z = -x-y;
        const axial = cubeToAxial(x,y,z);
        res.push(axial);
    }
    return res;
}
function lerp(a,b,t){ return a + (b-a)*t; }
function axialToCube(q,r){ const x=q, z=r, y=-x-z; return {x,y,z}; }
function cubeToAxial(x,y,z){ return [x,z]; }

// orientation overlay helpers
function showOrientationOverlay(q,r){
    const el = document.getElementById('hex-orient-overlay');
    if(!el) return;
    // build simple SVG showing N,NE,SE,S,SW,NW around center
    el.innerHTML = '';
    const ns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns,'svg');
    svg.setAttribute('width',160); svg.setAttribute('height',160);
    const cx = 80, cy = 80, R = 48;
    const circle = document.createElementNS(ns,'circle');
    circle.setAttribute('cx',cx); circle.setAttribute('cy',cy); circle.setAttribute('r',56);
    svg.appendChild(circle);
    const labels = [['N',0,-1],['NE',1,-1],['SE',1,0],['S',0,1],['SW',-1,1],['NW',-1,0]];
    labels.forEach(([lab,dq,dr],i)=>{
        const ang = -Math.PI/2 + i*(Math.PI/3);
        const x = cx + Math.cos(ang)*R;
        const y = cy + Math.sin(ang)*R;
        const t = document.createElementNS(ns,'text');
        t.setAttribute('x', x); t.setAttribute('y', y+4);
        t.setAttribute('text-anchor','middle');
        t.textContent = lab;
        svg.appendChild(t);
    });
    el.appendChild(svg);
    el.style.display = 'block';
}
function hideOrientationOverlay(){ const el=document.getElementById('hex-orient-overlay'); if(el) el.style.display='none'; }

// Direction label helpers
const LABEL_DIRS = [
    {label:'N', dq:0, dr:-1},
    {label:'NE', dq:1, dr:-1},
    {label:'SE', dq:1, dr:0},
    {label:'S', dq:0, dr:1},
    {label:'SW', dq:-1, dr:1},
    {label:'NW', dq:-1, dr:0}
];

function directionLabelFromDelta(dq, dr){
    for(const d of LABEL_DIRS) if(d.dq===dq && d.dr===dr) return d.label;
    return '?';
}

function labelFromCenter(q, r){
    // map angle to nearest of 6 labels used above
    const p = axialToPixel(q,r);
    const cx = 0, cy = 0; // center at pixel(0,0) for angle calculation
    const ang = Math.atan2(p.y - cy, p.x - cx);
    // convert angle so that -PI/2 (up) is N and then rotate by 60deg sectors
    let base = ang + Math.PI/2;
    while(base < 0) base += Math.PI*2;
    const sector = Math.floor((base) / (Math.PI/3)) % 6;
    return LABEL_DIRS[sector].label;
}

function getPieceFullName(key) {
    const names = {
        'Q': 'Queen',
        'A': 'Ant', 
        'B': 'Beetle',
        'G': 'Grasshopper',
        'S': 'Spider'
    };
    return names[key] || key;
}

function pathStepsBetween(sq, sr, eq, er){
    const result = [];
    let curQ = sq, curR = sr;
    const targetCube = axialToCube(eq, er);
    const maxIter = 12;
    for(let i=0;i<maxIter;i++){
        if(curQ===eq && curR===er) break;
        // choose neighbor that minimizes cube distance to target
        let best = null, bestDist = Infinity, bestStep = null;
        for(const d of DIRS){
            const nq = curQ + d.dq, nr = curR + d.dr;
            const dist = hexDistanceAxial(nq,nr, eq,er);
            if(dist < bestDist){ bestDist = dist; best = [nq,nr]; bestStep = d; }
        }
        if(!best) break;
        result.push(best);
        curQ = best[0]; curR = best[1];
    }
    return result;
}

function hexDistanceAxial(aq, ar, bq, br){
    const a = axialToCube(aq, ar), b = axialToCube(bq, br);
    return Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y), Math.abs(a.z-b.z));
}

// Coordinate overlay system
let coordinateOverlayVisible = false;
const coordinateLabels = new Map();

function toggleCoordinateOverlay() {
    coordinateOverlayVisible = !coordinateOverlayVisible;
    const button = document.getElementById('toggle-coordinates');
    
    if (coordinateOverlayVisible) {
        button.textContent = 'Hide Coordinates';
        showCoordinateLabels();
    } else {
        button.textContent = 'Show Coordinates';
        hideCoordinateLabels();
    }
}

function showCoordinateLabels() {
    // Create labels for all existing cells plus a reasonable border around them
    const existingCells = Array.from(cells.keys()).map(key => {
        const [q, r] = key.split(',').map(Number);
        return { q, r };
    });
    
    // Find bounds of existing cells
    let minQ = 0, maxQ = 0, minR = 0, maxR = 0;
    existingCells.forEach(({q, r}) => {
        minQ = Math.min(minQ, q);
        maxQ = Math.max(maxQ, q);
        minR = Math.min(minR, r);
        maxR = Math.max(maxR, r);
    });
    
    // Expand bounds by 3 in each direction
    const border = 3;
    for (let q = minQ - border; q <= maxQ + border; q++) {
        for (let r = minR - border; r <= maxR + border; r++) {
            createCoordinateLabel(q, r);
        }
    }
}

function createCoordinateLabel(q, r) {
    const key = `${q},${r}`;
    if (coordinateLabels.has(key)) return; // Already exists
    
    const localPixel = axialToPixel(q, r);
    const globalPos = boardLayer ? boardLayer.toGlobal(new PIXI.Point(localPixel.x, localPixel.y)) : { x: localPixel.x + window.innerWidth/2, y: localPixel.y + window.innerHeight/2 };
    
    const label = document.createElement('div');
    label.className = 'coordinate-label';
    label.textContent = `${q},${r}`;
    label.style.left = `${globalPos.x}px`;
    label.style.top = `${globalPos.y}px`;
    
    document.body.appendChild(label);
    coordinateLabels.set(key, label);
}

function hideCoordinateLabels() {
    coordinateLabels.forEach(label => {
        if (label.parentNode) {
            label.parentNode.removeChild(label);
        }
    });
    coordinateLabels.clear();
}

function updateCoordinateLabels() {
    if (!coordinateOverlayVisible) return;
    
    // Update positions of all labels based on current PIXI stage transform
    coordinateLabels.forEach((label, key) => {
        const [q, r] = key.split(',').map(Number);
        const localPixel = axialToPixel(q, r);
        
        // Transform through PIXI stage to get screen coordinates
        const globalPos = boardLayer.toGlobal(new PIXI.Point(localPixel.x, localPixel.y));
        
        label.style.left = `${globalPos.x}px`;
        label.style.top = `${globalPos.y}px`;
    });
}

// Hook into PIXI render loop to update coordinate positions
let coordinateUpdateRequested = false;

function requestCoordinateUpdate() {
    if (!coordinateUpdateRequested) {
        coordinateUpdateRequested = true;
        requestAnimationFrame(() => {
            updateCoordinateLabels();
            coordinateUpdateRequested = false;
        });
    }
}

// Initialize coordinate toggle button
document.addEventListener('DOMContentLoaded', () => {
    const button = document.getElementById('toggle-coordinates');
    if (button) {
        button.addEventListener('click', toggleCoordinateOverlay);
    }
    
    // Update coordinates when window resizes or stage transforms
    window.addEventListener('resize', requestCoordinateUpdate);
    
    // Hook into PIXI ticker if available
    if (window.app && window.app.ticker) {
        window.app.ticker.add(requestCoordinateUpdate);
    }
});
